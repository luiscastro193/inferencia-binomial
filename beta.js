async function Module(moduleArg={}){var moduleRtn;var c=moduleArg,e=import.meta.url,f="",h;try{f=(new URL(".",e)).href}catch{}h=async a=>{a=await fetch(a,{credentials:"same-origin"});if(a.ok)return a.arrayBuffer();throw Error(a.status+" : "+a.url);};var k=console.error.bind(console),l=!1,m,n,p=!1;function q(a){a="Aborted("+a+")";k(a);l=!0;a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info.");n?.(a);throw a;}var r;
async function t(a){try{var b=await h(a);return new Uint8Array(b)}catch{}throw"both async and sync fetching of the wasm failed";}async function u(a,b){try{var d=await t(a);return await WebAssembly.instantiate(d,b)}catch(g){k(`failed to asynchronously prepare wasm: ${g}`),q(g)}}
async function v(a){var b=r;try{var d=fetch(b,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(d,a)}catch(g){k(`wasm streaming compile failed: ${g}`),k("falling back to ArrayBuffer instantiation")}return u(b,a)}class w{name="ExitStatus";constructor(a){this.message=`Program terminated with exit(${a})`;this.status=a}}
var x={},y=a=>{if(!l)try{a()}catch(b){if(!(b instanceof w||"unwind"==b))throw b;}},z,A,B={c:()=>q(""),b:()=>{},d:(a,b)=>{x[a]&&(clearTimeout(x[a].id),delete x[a]);if(!b)return 0;var d=setTimeout(()=>{delete x[a];y(()=>z(a,performance.now()))},b);x[a]={id:d,l:b};return 0},a:a=>{throw new w(a);}},C;
C=await (async function(){var a={a:B};r??=c.locateFile?f+"beta.wasm":(new URL("beta.wasm",import.meta.url)).href;a=C=(await v(a)).instance.exports;c._set_params=a.g;c._quantile=a.h;c._pdf=a.i;z=a.j;A=a.e;a=A.buffer;new Int8Array(a);new Int16Array(a);new Uint8Array(a);new Uint16Array(a);new Int32Array(a);new Uint32Array(a);new Float32Array(a);new Float64Array(a);new BigInt64Array(a);new BigUint64Array(a);return C}());c.calledRun=!0;l||(p=!0,C.f(),m?.(c));
p?moduleRtn=c:moduleRtn=new Promise((a,b)=>{m=a;n=b});
;return moduleRtn}export default Module;
